package com.datastructure.sort;

/**
 * 冒泡排序
 */
public class BubbleSort {

    public void sort(int[] arr) {
        /**
         * 假设对 50, 30, 10, 20, 6 进行 从小到大 排序
         * 相邻两个元素做对比，如果 当前元素 > 后一个元素，那么
         * 交换位置。
         *
         * 第 1 遍循环
         *
         * 50, 30, 10, 20, 6
         * 30, 50, 10, 20, 6
         * 30, 10, 50, 20, 6
         * 30, 10, 20, 50, 6
         * 30, 10, 20, 6，50
         *
         * 可以看到 50 归位，也就是到它应该所在的位置。
         *
         * 那么剩下 4个 元素需要对比
         *
         * 第 2 遍循环
         * 30, 10, 20, 6，50
         * 10, 30, 20, 6，50
         * 10, 20, 30, 6，50
         * 10, 20, 6, 30，50
         *
         * 可以看到 30 归位，也就是到它应该所在的位置。
         *
         * 那么剩下 3个 元素需要对比
         *
         * 第 3 遍循环
         * 10, 20, 6, 30，50
         * 10, 20, 6, 30，50
         * 10, 6, 20, 30，50
         *
         * 可以看到 20 归位，也就是到它应该所在的位置。
         *
         * 那么剩下 2个 元素需要对比
         *
         * 第 4 遍循环
         * 10, 6, 20, 30，50
         * 6, 10, 20, 30，50
         *
         * 可以看到 10 归位，也就是到它应该所在的位置。
         * 剩余 1个 元素，也就不需要做对比了。
         *
         * 那么数组长度是 n, 经过 n - 1 次的循环，得到结果。
         *
         */
        int length = arr.length;
        int num = length - 1;
        // 用还交换元素的 临时 变量
        int temp = 0;
        /**
         * 用来优化算发的。
         * 因为当传入的数组，有可能是已经排序好的。
         * 也有可能当进行 1遍，或是 2遍就排序好了。
         * 那么再接着执行循环就是浪费了。
         *
         * 当 flag = false 时，说明一次交换也没有发生，那就说明是有序的。
         */
        boolean flag = false;
        for (int i = 0; i < num; i++) {

            /**
             * 假设 length = 5
             *
             * 这里 减去 i，就是相应的剩余需要做比较的元素的个数。
             *  比如 i = 1 时, 已经归位了 1个 数，只需对剩余的 length - i = 5 - 1 = 4 个元素做对比。
             *  比如 i = 2 时, 已经归位了 2个 数，只需对剩余的 length - i = 5 - 2 = 3 个元素做对比。
             *
             * 这里再 减去 1，是为了避免下标 越界。
             * 因为是 j 和 j + 1 做对比
             */
            for (int j = 0; j < length - i - 1; j++) {
                int nextIndex = j + 1;
                if (arr[j] > arr[nextIndex]) {
                     temp = arr[j];
                    arr[j] = arr[nextIndex];
                    arr[nextIndex] = temp;

                    flag = true; // 发生了交换
                }
            }

            if (!flag) { // flag = false，说明一次交换也没有发生，那就说明是有序的。
                break;
            } else { // flag = true，说明发生过交换，那再这里重置一下。
                /**
                 * 为什么重置。
                 * 因为当这次 flag = true 时，有可能已经排序好了。
                 * 那么进行下次遍历的时候，不会发生交换，flag = false，会走上面的 if 语句，结束循环。
                 */
                flag = false;
            }
        }
    }
}
